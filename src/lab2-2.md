# 知识储备

一个程序需要执行，它必须被加载到内存中且映射到物理地址。随着程序的运行程序，可以通过产生的绝对地址来访问内存中的数据和指令，最后当程序中止后，它的内存和空间得以释放，这样下一个程序可以被加载并执行。

### 动态分配物理内存

如果按地址顺序分配即**静态分配**，看上去合理的利用了内存，但是如果涉及到回收内存中原本连续的空间就会空出一片空间。比如，需要将一个文件读到内存进行处理， 而且必须将文件一次性完整读进来处理才能正确。此时，可以选择声明一个栈上的局部变量或者数据段中的全局变量作为缓冲区来暂存 文件的内容。但在编程的时候我们并不知道待处理的文件的大小，只能根据经验将缓冲区的大小设置为某一固定常数。在代码真正运行 的时候，如果待处理的文件很小，那么缓冲区多出的部分是被浪费掉的，也拉高了应用的内存占用；如果待处理的文件很大，应用则 无法正常运行。就像缓冲区的大小设置一样，还有很多其他的问题来源于某些数据结构需求的内存大小取决于应用的实际运行情况。而如果无法填补这片空间，那么其可能不会被再次利用，久而久之整个内存中就会充满了这种碎片。

**动态分配**就是指应用不仅在自己的地址空间放置那些 自编译期开始就大小固定、用于静态内存分配的逻辑段（如全局数据段、栈段），还另外放置一个大小可以随着应用的运行动态增减 的逻辑段，它的名字叫做堆。同时，应用还要能够将这个段真正管理起来，即支持在运行的时候从里面分配一块空间来存放变量，而 在变量的生命周期结束之后，这块空间需要被回收以待后面的使用。如果堆的大小固定，那么这其实就是一个连续内存分配问题， 我们课上所介绍到的那些算法都可以随意使用。取决于应用的实际运行状况，每次分配的空间大小可能会有不同，因此也会产生外碎片。 如果在某次分配的时候发现堆空间不足，我们并不会像上一小节介绍的那样移动变量的存放位置让它们紧凑起来从而释放间隙用来分配 （事实上它很难做到这一点）， 一般情况下应用会直接通过系统调用，来向内核请求增加它地址空间内堆的大小，之后 就可以正常分配了。当然，这一类系统调用也能缩减堆的大小。

所以使用Linux经典的动态内存分配算法——伙伴系统（Buddy System）来帮助进行内存的分配。需要声明的一点是，其实操作系统一般不会以字节为单位的分配内存，通常操作系统以页作为分配内存的单位。

![image-20210817133922183](F:\rCoreBook\hm1229.github.io\book\资源文件\实验二.assets\image-20210817133922183.png)